<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Step Counter Visualization</title>
    <!-- Preload the sprite sheet -->
    <link rel="preload" href="8 Direction Walk Sheets (10 Colors)/Blue/blue_walk_EAST-Sheet.png" as="image">
</head>
<body>
    <!-- Theme Selector -->
    <div class="theme-selector">
        <select id="theme-select">
            <option value="auto">Auto</option>
            <option value="light">Light</option>
            <option value="dark">Dark</option>
        </select>
    </div>

    <!-- Section 1: Introduction -->
    <section id="intro" class="section">
        <h1>How does your phone count your steps? üö∂‚Äç‚û°Ô∏èüö∂‚Äç‚ôÄÔ∏è‚Äç‚û°Ô∏è</h1>
        <h2>Ryan Batubara, Isaiah Fang, Matt Tokunaga</h2>
        <h3> <a href="https://docs.google.com/document/d/1xJ1Rywjtpx7pNN0VqV02o82idn6ey_pL3LhCW_lVaDs/edit?usp=sharing">Link to writeup</a></h3>
        <h3><a href="https://physionet.org/content/minute-level-step-count-nhanes/1.0.0/">Link to physionet data</a></h3>
        <h3><a href="https://doi.org/10.1093/biostatistics/kxz033">Link to original paper</a></h3>
    </section>

    <!-- Section 2: Visual Recognition -->
    <section id="visual-recognition" class="section">
        <h1>If you saw a person walking, <br> you could probably count their steps.</h1>
        <div id="walking-man-container" class="sprite-container"></div>
    </section>

    <!-- Section 3: Computer Approach -->
    <section id="computer-approach" class="section">
        <h1>But how would you make a computer count steps?</h1>
        <p>One idea is measuring movement and finding its magnitude.</p>
        <div class="plot-container">
            <svg id="basic-functionplot"></svg>
        </div>
        <p>Then, you compare this acceleration magnitude data to a pattern:</p>
        <div class="plot-container">
            <svg id="template"></svg>
        </div>
        <p>Researchers found that this shape is what a step looks like accelerometer data.</p>
        <p>Once you have your acceleration magnitude data, as well as this pattern, you can simply find the similarity between this pattern and your data at each possible timestamp. Timestamps with high similarity are likely where someone's step started. By counting the number of timestamps with high similarity, we can count the number of steps!</p>
    </section>
    <!-- Section 4: Similarity Calculation -->
     <section id="similarity-calculation" class="section">
        <h1>How is similarity calculated?</h1>
        <h2>We simply take the two functions, multiply them, and integrate the result!</h2>
        <h2><span style="color: green">Green</span> = <span style="color: var(--plot-line-color-2)">Red</span> &sdot; <span style="color: var(--plot-line-color-1)">Blue</span></h2>
        <h2><span style="color: orange">Similarity</span> = <span style="font-size: 48pt">&int;</span> <span style="color: green">Green</span></h2>
        <h3>Example #1: A close match!</h3>
        <div class="plots-wrapper">
            <div class="plot-container">
                <svg id="sim-calc-top-left"></svg>
            </div>
            <div class="plot-container">
                <svg id="sim-calc-top-right"></svg>
            </div>
        </div>
        <h3>Example #2: Not a close match at all!</h3>
        <div class="plots-wrapper">
            <div class="plot-container">
                <svg id="sim-calc-bottom-left"></svg>
            </div>
            <div class="plot-container">
                <svg id="sim-calc-bottom-right"></svg>
            </div>
        </div>
        <h3>Our data is piecewise linear just like these functions, we just have way more points.</h3>
     </section>

    <!-- Section 5: CWT Transform -->
    <section id="cwt-transform" class="section">
        <h1>Finding timestamps with high similarity</h1>
        <p>At each timestamp, you find the similarity between the data and a step pattern beginning at that timestamp.</p>
        <div class="controls">
            <label id="tau-label">
                Tau
                <input id="tau" type="range" min="0" max="800" value="0">
            </label>
            <label id="sigma-label">
                Sigma
                <input id="sigma" type="range" min="0.1" max=".5" step="0.01" value=".4">
            </label>
        </div>
        <h2>This is a graph of the similarity at each timestamp, as well as the translated pattern that we're comparing to the accelerometer data</h2>
        <div class="plots-wrapper">
            <div class="plot-container">
                <svg id="parameterplot"></svg>
            </div>
            <div class="plot-container">
                <svg id="functionplot"></svg>
            </div>
        </div>
        
        <div class="note-container">
            <label for="note">A minor note on the step pattern </label>
            <div id="note" class="note-text">
                You might have noticed that for some particular bad matches, our similarity is negative. But how is that possible? We have two strictly positive functions, shouldn't they multiply to get another strictly positive function, which would have a positive integral? The answer is yes! The step pattern on the graph is actually a scaled and translated version of the real thing. The real thing is centered on the origin and actually has mean zero. This is because if you don't impose this restriction, you could always get a step pattern that gives higher similarity by just translating your pattern upwards, since you would be integrating a bigger and bigger function.
            </div>
        </div>

    </section>

    <!--Section 6: Counting Peaks-->
    <section id="counting-peaks" class="section">
        <h1>Now we just count the number of peaks in the similarity scores</h1>
        <h2>How exactly? Here's one easy way.</h2>

        <div class="plots-wrapper">
            <div id="example-side-explanation">
                <div id="example-explanation-text">
                    You simply take every data point that's the biggest in some interval around itself. Wider intervals will ignore subsequent peaks and smaller intervals will get most local maximums, even ones that are next to bigger local maximums.              
                </div>
                <h3 style="margin-top: 2em" style="justify-content: center">Click to see how interval width can affect the number of peaks</h3>
                <div id="interval-selector">
                    <label>
                        <input type="radio" name="interval" value="wide" checked>
                        Wide Interval
                    </label>
                    <label>
                        <input type="radio" name="interval" value="narrow">
                        Narrow Interval
                    </label>
                </div>
            </div>
            <div class="plot-container">
                <svg id="peak-counting-example"></svg>
            </div>
        </div>
        <h3>To find the peaks in our similarity scores, we use the most natural interval width: one the same length as our step pattern width (1 second). This is the result:</h3>
        <div class="plots-wrapper">
            <div class="plot-container">
                <svg id="peak-counting-real"></svg>
            </div>
        </div>
        <h3>These peaks in similarity correspond to the following 10 steps:</h3>
        <div class="plots-wrapper">
            <div class="plot-container">
                <svg id="acc-data-with-steps"></svg>
            </div>
        </div>
        Notice how the end of one step generally lines up with the beginning of the next step! This is exactly what we want, since walking is cyclic and steps are discrete.
        <h2>And we're done! The algorithm found 10 peaks, so we have 10 steps! We've successfully counted the number of steps!</h2>
    </section>

    <script type="module" src="main.js"></script>
    <script type="module">
        import WalkingMan from './man.js';
        
        // Initialize the walking man animation
        const walkingMan = new WalkingMan('walking-man-container', {
            fps: 8,
            showControls: true,
            // Let the class calculate the frame width automatically
            // based on the sprite sheet dimensions
        });
        
        walkingMan.play();
        
        // Theme selector functionality
        const themeSelect = document.getElementById('theme-select');
        
        // Check for system preference
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
        
        // Set initial theme based on system preference if auto is selected
        function setInitialTheme() {
            const savedTheme = localStorage.getItem('theme');
            
            if (savedTheme) {
                themeSelect.value = savedTheme;
                if (savedTheme === 'dark') {
                    document.body.setAttribute('data-theme', 'dark');
                } else if (savedTheme === 'light') {
                    document.body.setAttribute('data-theme', 'light');
                } else if (savedTheme === 'auto') {
                    if (prefersDarkScheme.matches) {
                        document.body.setAttribute('data-theme', 'dark');
                    } else {
                        document.body.setAttribute('data-theme', 'light');
                    }
                }
            } else {
                // Default to auto
                themeSelect.value = 'auto';
                if (prefersDarkScheme.matches) {
                    document.body.setAttribute('data-theme', 'dark');
                }
            }
        }
        
        // Handle theme changes
        themeSelect.addEventListener('change', function() {
            const theme = this.value;
            localStorage.setItem('theme', theme);
            
            if (theme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
            } else if (theme === 'light') {
                document.body.setAttribute('data-theme', 'light');
            } else if (theme === 'auto') {
                if (prefersDarkScheme.matches) {
                    document.body.setAttribute('data-theme', 'dark');
                } else {
                    document.body.setAttribute('data-theme', 'light');
                }
            }
        });
        
        // Listen for system theme changes if auto is selected
        prefersDarkScheme.addEventListener('change', function(e) {
            if (themeSelect.value === 'auto') {
                if (e.matches) {
                    document.body.setAttribute('data-theme', 'dark');
                } else {
                    document.body.setAttribute('data-theme', 'light');
                }
            }
        });
        
        // Initialize theme
        setInitialTheme();
        
        // Smooth scrolling for navigation
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });
    </script>
</body>
</html>